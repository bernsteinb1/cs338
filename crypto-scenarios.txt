=====Simple Communication Standards=====
1. Since we are assuming that AITM is impossible, it would be easiest to use Diffie Hellman to arrive at a shared key for something like AES and then encrypt the message using that shared secret key. This is better than something like public-key encryption because it is faster and prevents an Eve from getting any information.

2. To make sure that Bob can detect a change, we can use a cryptographic hash along with the message. Bob can then hash the message himself and make sure it matches, but we still need to ensure that Mal can't modify the message. Because the hash is relatively short, you can encrypt it with Bob's public key (E(P_Bob, H(M))), which makes it so Mal can't change the hash because she does not have Bob's private key. Then, if Mal changes the message, the hash will not match and Bob will be able to tell. This is similar to signing, but we encrypt with Bob's key instead of Alice's

3. Alice and Bob start by coming to a shared AES key through Diffie-Hellman. Using AES, Alice encrypts the document E(K, D), which prevents Eve from reading it. Alice then signs the document by encrypting the hash with her private key Sig=E(S_A, H(D)). This works because only Alice could encrypt the hash with her secret key, since it is secret. Then Bob can decrypt the document and see the hash value. Using Alice's public key, Bob decrypts the signature and compares the hash of the document to the hash of the signature. If they match, it must be from Alice since we are assuming that Alice's public key is correct.

=====Breaking Security=====
4. Alice could claim that Bob stole her secret key and used it to make a fake signature. This is quite plausible, depending on how Alice claims Bob got the key, if she says Bob got it through physical threats, that is believable. Alice could claim that Bob found the key by discovering the prime factorization. This is implausible as there is no known algorithm that can find prime factors quickly enough to discover the secret key. Finally, Alice could claim that Bob cracked the hashing algorithm to invent a new document that hashes to the same value. Again, this is not plausible as we do not know any ways to hack algorithms like SHA-256 to get identical output.

5. Sig_CA will be composed of the hash of the public key for Bob, encrypted using the secret key of the Certificate Authority. The actual formula that would be used is Sig_CA=E(S_CA, H(P_B)). This works because Alice can take the signature, decrypt it with the Trusted Third Platform's public key, and get a hash of Bob's public key. Since Alice should have Bob's public key already, Alice can hash that as well and compare the two values. This works because no one else would be able to encrypt using the secret key of the certificate authority, so we know that the signature must have come from them if they match.

6. It is not enough for Alice to get the certificate because certificates are essentially public information. I could query YouTube and get a signature from them. Then I could send that signature to anybody and pretend I was YouTube. The actual problem is that I would not have secret keys, so I could not decrypt a message that was sent and intended for Bob. That is why Alice can make a test of a random number encrypted with Bob's public key, I would not be able to decrypt it and could not pass the test.

7. One spot this breaks is if I am able to fool the CA into believing I am "bob.com." Then I could give bob.com a public key that is actually my public key and I could receive all data from bob.com by sharing the signature I got from the Certificate Authority. Another critical flaw would be if I could get the secret key for the certificate authority and then sign a bunch of fake certificates. I could then make anybody's public key look like whatever I wanted it to.
